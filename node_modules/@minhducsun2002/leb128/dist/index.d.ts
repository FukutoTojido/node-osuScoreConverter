/// <reference types="node" />
/**
 * Class to work with unsigned LEB128 integers.
 * @see https://en.wikipedia.org/wiki/LEB128#Encoding_format
 */
export declare class UnsignedLEB128 {
    /**
     * Decode a Buffer into a number.
     * @param buf Buffer containing the representation in LEB128
     * @param offset Offset to read from
     */
    static decode(buf: Buffer, offset?: number): number;
    /**
     * Create a LEB128 Buffer from a number
     * @param number Number to convert from
     */
    static encode(number: number): Buffer;
    private static check;
    /**
     * Return the offset that the byte at which ends the stream
     * @param buf Buffer to scan
     * @param offset Offset to start scanning
     */
    private static $scanForNullBytes;
    /**
     * Return the index that the byte at which ends the stream
     * @param buf Buffer to scan
     * @param offset Offset to start scanning
     */
    static getLength(buf: Buffer, offset?: number): number;
}
export declare class SignedLEB128 {
    private static $ceil7mul;
    private static check;
    /**
     * Create a LEB128 Buffer from a number
     * @param number Number to convert from. Must be less than 0.
     */
    static encode(number: number): Buffer;
    /**
     * Decode a Buffer into a (signed) number.
     * @param buf Buffer containing the representation in LEB128
     * @param offset Offset to read from
     */
    static decode(buf: Buffer, offset?: number): number;
}
export declare class LEB128 {
    /**
     * Create a LEB128 Buffer from a number
     * @param number Number to convert from.
     */
    static encode: (n: number) => Buffer;
    /**
     * Decode a Buffer into a (signed) number.
     * @param buf Buffer containing the representation in LEB128
     * @param offset Offset to read from
     * @param s Whether the output number is negative
     */
    static decode: (buf: Buffer, offset?: number, s?: boolean) => number;
}
