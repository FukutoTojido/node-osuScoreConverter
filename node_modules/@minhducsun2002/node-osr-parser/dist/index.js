"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Replay = exports.Mods = exports.StandardKeypress = exports.Gamemode = void 0;
const lzma_1 = __importDefault(require("lzma"));
const int64_buffer_1 = require("int64-buffer");
const leb128_1 = require("@minhducsun2002/leb128");
/**
 * Game mode constants
 */
var Gamemode;
(function (Gamemode) {
    Gamemode[Gamemode["STANDARD"] = 0] = "STANDARD";
    Gamemode[Gamemode["TAIKO"] = 1] = "TAIKO";
    Gamemode[Gamemode["CATCH"] = 2] = "CATCH";
    Gamemode[Gamemode["MANIA"] = 3] = "MANIA";
})(Gamemode = exports.Gamemode || (exports.Gamemode = {}));
/**
 * Key press in `Replay.replayData`.
 */
var StandardKeypress;
(function (StandardKeypress) {
    StandardKeypress[StandardKeypress["Mouse1"] = 1] = "Mouse1";
    StandardKeypress[StandardKeypress["Mouse2"] = 2] = "Mouse2";
    StandardKeypress[StandardKeypress["Key1"] = 4] = "Key1";
    StandardKeypress[StandardKeypress["Key2"] = 8] = "Key2";
    StandardKeypress[StandardKeypress["Smoke"] = 16] = "Smoke";
})(StandardKeypress = exports.StandardKeypress || (exports.StandardKeypress = {}));
/**
 * Mod in `Replay.mods`
 */
var Mods;
(function (Mods) {
    Mods[Mods["None"] = 0] = "None";
    Mods[Mods["NoFail"] = 1] = "NoFail";
    Mods[Mods["Easy"] = 2] = "Easy";
    Mods[Mods["TouchDevice"] = 4] = "TouchDevice";
    Mods[Mods["Hidden"] = 8] = "Hidden";
    Mods[Mods["HardRock"] = 16] = "HardRock";
    Mods[Mods["SuddenDeath"] = 32] = "SuddenDeath";
    Mods[Mods["DoubleTime"] = 64] = "DoubleTime";
    Mods[Mods["Relax"] = 128] = "Relax";
    Mods[Mods["HalfTime"] = 256] = "HalfTime";
    /** Must be set along with DoubleTime (NC only gives 576) */
    Mods[Mods["Nightcore"] = 512] = "Nightcore";
    Mods[Mods["Flashlight"] = 1024] = "Flashlight";
    Mods[Mods["Autoplay"] = 2048] = "Autoplay";
    Mods[Mods["SpunOut"] = 4096] = "SpunOut";
    Mods[Mods["Autopilot"] = 8192] = "Autopilot";
    /** Must be set along with SuddenDeath */
    Mods[Mods["Perfect"] = 16384] = "Perfect";
    Mods[Mods["Key4"] = 32768] = "Key4";
    Mods[Mods["Key5"] = 65536] = "Key5";
    Mods[Mods["Key6"] = 131072] = "Key6";
    Mods[Mods["Key7"] = 262144] = "Key7";
    Mods[Mods["Key8"] = 524288] = "Key8";
    Mods[Mods["FadeIn"] = 1048576] = "FadeIn";
    Mods[Mods["Random"] = 2097152] = "Random";
    Mods[Mods["Cinema"] = 4194304] = "Cinema";
    Mods[Mods["Target"] = 8388608] = "Target";
    Mods[Mods["Key9"] = 16777216] = "Key9";
    Mods[Mods["KeyCoop"] = 33554432] = "KeyCoop";
    Mods[Mods["Key1"] = 67108864] = "Key1";
    Mods[Mods["Key3"] = 134217728] = "Key3";
    Mods[Mods["Key2"] = 268435456] = "Key2";
    Mods[Mods["ScoreV2"] = 536870912] = "ScoreV2";
    Mods[Mods["Mirror"] = 1073741824] = "Mirror";
})(Mods = exports.Mods || (exports.Mods = {}));
/**
 * Class representing a replay.
 * @see https://osu.ppy.sh/help/wiki/osu!_File_Formats/Osr_(file_format)/
 * @public
 */
class Replay {
    constructor(content) {
        this.buffer = content;
    }
    /**
     * Check whether offset is still in range.
     * If not, throw
     */
    checkOffset() {
        if (this.offset >= this.buffer.byteLength)
            throw new Error('Replay data ended unexpectedly');
    }
    /**
     * Read a byte from the buffer, incrementing offset after the read operation
     */
    readByte() {
        this.checkOffset();
        const out = this.buffer.slice(this.offset, this.offset + 1);
        this.offset++;
        return out.readUInt8(0);
    }
    readInt16() {
        this.checkOffset();
        const out = this.buffer.slice(this.offset, this.offset + 2);
        this.offset += 2;
        return out.readInt16LE(0);
    }
    readInt32() {
        this.checkOffset();
        const out = this.buffer.slice(this.offset, this.offset + 4);
        this.offset += 4;
        return out.readInt32LE(0);
    }
    readInt64() {
        this.checkOffset();
        const out = this.buffer.slice(this.offset, this.offset + 8);
        this.offset += 8;
        return new int64_buffer_1.Uint64LE(out).toNumber();
    }
    readString() {
        this.checkOffset();
        const present = this.buffer.slice(this.offset, this.offset + 1).readInt8(0) === 0x0b;
        this.offset++;
        if (!present)
            return '';
        else {
            const len = leb128_1.UnsignedLEB128.getLength(this.buffer, this.offset);
            const num = leb128_1.UnsignedLEB128.decode(this.buffer, this.offset);
            this.offset += len + 1;
            const out = this.buffer.slice(this.offset, this.offset + num).toString();
            this.offset += num;
            return out;
        }
    }
    readBinary(length) {
        this.checkOffset();
        const binary = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return binary;
    }
    parseHealthbar(s) {
        let a = s.split(',').filter(a => a).map(a => a.trim());
        return a.map(s => {
            const [timestamp, percentage] = s.split('|').map(a => +a);
            return { timestamp, percentage };
        });
    }
    /** Deserializing the beatmap passed. */
    async deserialize() {
        // (re-)init
        this.offset = 0;
        this.gamemode = this.version = this.score = this.maxCombo = this.perfect = this.scoreID = null;
        this.accuracies = {
            count300k: 0,
            count300: 0,
            count100k: 0,
            count100: 0,
            count50: 0,
            countMiss: 0
        };
        this.gamemode = this.readByte();
        this.version = this.readInt32();
        this.md5map = this.readString();
        this.player = this.readString();
        this.md5replay = this.readString();
        this.accuracies = {
            count300: this.readInt16(),
            count100: this.readInt16(),
            count50: this.readInt16(),
            count300k: this.readInt16(),
            count100k: this.readInt16(),
            countMiss: this.readInt16()
        };
        this.score = this.readInt32();
        this.maxCombo = this.readInt16();
        this.perfect = this.readByte();
        this.mods = this.readInt32();
        this.healthbar = this.parseHealthbar(this.readString());
        let a = (BigInt(this.readInt64()) - EPOCH) / 10000n;
        this.timestamp = new Date(Number(a));
        let replayLength = this.readInt32();
        let replayBinary = this.readBinary(replayLength);
        let decompressed = lzma_1.default.decompress(replayBinary);
        if (decompressed instanceof Uint8Array) {
            this.replayData = new TextDecoder().decode(decompressed);
        }
        else {
            this.replayData = decompressed;
        }
        this.scoreID = this.readInt64();
        return this;
    }
}
exports.Replay = Replay;
const EPOCH = 621355968000000000n;
